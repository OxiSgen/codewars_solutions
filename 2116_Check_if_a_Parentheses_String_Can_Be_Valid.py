"""
ЗАДАЧА О КОРРЕКТНОЙ СКОБОЧНОЙ ПОСЛЕДОВАТЕЛЬНОСТИ С ВОЗМОЖНОСТЬЮ ЗАМЕНЫ СКОБОК В НЕКОТОРЫХ МЕСТАХ.

s      -> скобочная последовательность
locked -> последовательность 0 и 1
Если locker[i] == 0, это означает, что в s[i] возможно заменить скобку на противоположную
Пример: 
s      = "))()))"
locked = "010100"
          012345 
Вернёт True, так как скобки с индексами 0 и 4 можно поменять на противоположные и получить -> "()()()"
"""
def canBeValid(self, s: str, locked: str) -> bool:
    """
    Смысл решения заключается в двух проходах по строке со скобками слева направо и справа налево
    При первом прохоже l -> r мы смотрим на открывающие скобки. 
    Если скобка == "(" ИЛИ в строке locked на данной позиции 0, баланс увеличиваем на 1, в противном случае уменьшеаем на 1.
    Если на ЛЮБОЙ итерации оказывается, что у баланс отрицателен, возвращаем False из внутренней функции и из внешней (ввиду ленивости логического оператора 'and')
    
    При втором проходе r ->  выполняем всё то же самое, но для закрывающих скобок
    Результат работы внешней функции True только в случае истиности обоих проходов. 
    
    Два прохода необходимы для корректной обработки вот таких случаев:
    s      = "))(("
    locked = "0011"
    Один проход l->r вернул бы True.
    
    Альтернативный подход к решению этой задачи с одним циклов - динамическое программирование. 
    """
    if len(s) % 2: return False
    def s_pass(s, locked, rot, balance = 0):
        for el, lock in zip(s, locked):
            balance += 1 if el == rot or lock == '0' else -1
            if balance < 0:
                return False
        return True
    return s_pass(s, locked, "(") and s_pass(s[::-1], locked[::-1], ")")
