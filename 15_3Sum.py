class Solution:
  '''
  Дан целочисленный массив nums, вернуть все триплеты [nums[i], nums[j], nums[k]],
  такие что i != j, i != k, и j != k, и nums[i] + nums[j] + nums[k] == 0.
  Обратите внимание, что в наборе решений не должно быть повторяющихся триплетов.
  '''
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        """ 
        Сложность алгоритма - O(n^2)
        """
        if len(nums) < 3: return []
        if len(nums) == 3 and not sum(nums): return [nums]    # Базовые случаи обработаем сразу.
        nums.sort()  # Cортировка - O(n*log(n))
        res = list()
        # my_sum = lambda a, b, c: a + b + c  Лямбда сильно замедляет выполнение на больших наборах данных за счёт дополнительных накладных расходов.
        for i in range(len(nums)-2):   # Вложенные циклы - O(n^2)
            if i != 0 and nums[i] == nums[i-1]: 
                # Избегаем повторяющихся триплетов. 
                # Если мы не на первой итерации цикла, и встречаем первый элемент такой же, как и предыдущий, его сразу можно пропустить
                continue
            l, r = i+1, len(nums) - 1  
            # Задачу свзодим к задаче 2sum. Первый элент выбираем в цикле for, 
            # left и right второй и третий элемент сводим с двух краёв оставшеся части массива.
            # Это возможно благодаря тому, что массив отсортирован.
            while r > l:
                s = nums[i] + nums[l] + nums[r]
                if s == 0:
                    res.append([nums[i], nums[l], nums[r]])
                    l += 1
                    r -= 1
                    # То же самое, что и выше, перед while. Мы проверяем для текущих l и r, не являются ли они такими же, как и предыдущие,
                    # если да, пропускаем их, так как они дадут повторяющуюся пару.
                    while l < r and nums[l] == nums[l-1]: 
                        l+=1
                    while l < r and nums[r] == nums[r+1]:
                        r-=1
                elif s < 0:
                    l += 1
                else:
                    r -= 1
        return res
