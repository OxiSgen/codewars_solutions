def generateParenthesis4(n):
    def generate(p, left, right, parens=[]):
        '''
        Значение аргумента по умолчанию выполняется во время определения, а не во время выполнения.
        parents не нужно передавать в качества аргумента в рекурсивных вызовых, как я делаю ниже
        '''
        if left:         generate(p + '(', left-1, right)
        if right > left: generate(p + ')', left, right-1)
        if not right:    parens += p,  # parens.append(p). Данный трюк делает из p кортеж
        return parens
    return generate('', n, n)


def balanced_parens(n, st="", op=0, cl=0, res=None):
    ''' Идиотский костыль для передачи иззменяемого list в рекурсивую функцию для inplace модернизации. '''
    if res is None: res = []
    '''Как и выше, первым мы обязательно помещаем открывающую скобку, так как все правильные скобочные последовательности n >= 1 начинаются с неё.'''
    if op < n: balanced_parens(n, st+"(", op+1, cl, res) # Если число открывающих меньше n. Условие с n, чтобы оно смогло выполниться при начальном состоянии op=0, cl=0
    if cl < op: balanced_parens(n, st+")", op, cl+1, res) # Добиваем закрывающими
    if op == cl == n: res.append(st)
    return res


def balanced_parens_stack(n):
    """
    Вариант без рекурсии (с самописным stack) для понимания принципа работы алгоритма.
    """
    res = []
    stack = [('', 0, 0)]
    while stack:
        temp, op, cl = stack.pop()
        if op < n: stack.append((temp+'(', op+1, cl))
        if cl < op: stack.append((temp + ')', op, cl+1))
        if op == cl == n: res.append(temp)
    return res


class MagicSoluthions:
    """
    Решения из комментариев. Это ещё предстоит переварить... :)
    """
    @staticmethod
    def generateParenthesis(n, open=0):
        """
        Если в последнем ретёрне поставить 0 вместо (not n) ничего не будет в выходном списке. Если 1, список с некоторыми лишними значениями
        Для n = 3 и замен (not n) на 0:
        Ожидаемое - ['((()))', '(()())', '(())()', '()(())', '()()()']
        Получается ['((()))', '(()())', '(())()', '(()))', '()(())', '()()()', '()())', '())', ')']
        Таким образом, n = 0 получается только на не корректных парах. Проанализировав результаты, можно так же прийти к выводу,
        что во всех неправильных последовательнсотях не хватает только открывающих скобок, которые записываются в рекурсинвных вызовах.
        
        Таким образом, в левом компрехеншине происходит три рекурсивных вызова, после которых n == 0, open == 3  => выходим из первого условия и возвращаем [")))"]
        прибавляем в первом комплехеншине к "(((" и получаем "((()))" в этой точке n == 1 и open == 2. После этого в этом кадре рекурсии переходим ко второму компрхеншину,
        в нём уменьшаем open и кладём новый кадр на стек, в котором n == open == 1. Снова делаем рекурсивный вызов из первого компрехэншона, получаем кадр n == 0, open == 2 
        и временную переменную "(()(" к которой после раскрутки прибавляем "))" получая вторую правильную последовательность в состоянии n == open == 1 и с управлением на втором
        компрехэншоне. Делаем ещё несколько вызовов:
        0. n == 1, open == 1, temp = "(()"
        1. n == 1, open == 0, temp = "(())"
        2. n == 0, open == 1, temp = "(())(".  возврат последнего ретёрна, после объединения, получаем следующую корретную последовательность "(())()".
        
        На данном этапе должна появиться некоретная последовательность, где n будет != 0. После возврата управления, мы перейдём во второй компрехэншин, гле получем кадр
        n == 1, open == -1, выйдем на внешний ретёрн и отсеем последовательность "(()))". После раскрутки стека, получим "(" ну и так далее ... 
       
        Ну или что-то типо того :)
        
        p.s. Что касается того, каким образом, например в первой последовательсности, увеличивается число открнывающих скобок, рассмотрим простой пример:
        def test_f(n):
            if n > 0:
                a = []
                for p in test_f(n - 1):
                    t = '(' + p
                    a.append(t)
                return a
            return [")))"]

        print(test_f(3))  ->  ["((()))"]
        
        В данном примере сначала создастся 3 кадра на стеке, вызоветется оператор return [")))"] и управление передастся на предыдущий кадр стека в цикл. В цикле
        мы сложим "(" + ")))". После этого произойдёт возврат "()))" в предыдущий кадр стека, где массив a ещё пустой и в него поместится "(()))". После ещё одной 
        раскрутки, попадём в нижний кадр стека, полохим в локальную a ["((()))"] и верём это значение.
        """
        if n > 0 <= open:
            return ['(' + p for p in MagicSoluthions.generateParenthesis(n - 1, open + 1)] + [')' + p for p in MagicSoluthions.generateParenthesis(n, open - 1)]
        return [')' * open] * (not n)
        # ------------------------------------------------------------------------------------------------------------------------------------------------------ #
        def generateParenthesis(n, open=0):
            """
            В такой форме становится чуть понятней
            """
            if n > 0 <= open:
                a = ['(' + p for p in MagicSoluthions.generateParenthesis(n - 1, open + 1)]
                print("a:", a) ''' !!! Почему то на всех принтах, кроме послденего (в последнем кадре рекурсии) у элементов списов нет первых элементов. !!! '''
                b = [')' + p for p in MagicSoluthions.generateParenthesis(n, open - 1)]
                print("b:", b)
                return a + b
            return [')' * open] * (not n)

    @staticmethod
    def generateParenthesis2(n):
        """
        Прикольный пример использования рекурсивных генераторов, но совершает много лишних шагов, из-за чего медленней прочих.
        """
        def generate(p, left, right):
            if right >= left >= 0:
                if not right: yield p
                yield from generate(p + '(', left-1, right)
                yield from generate(p + ')', left, right-1)
        return list(generate('', n, n))
